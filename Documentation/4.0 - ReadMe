0. USER INFORMATION

This is designed first and foremost for crypto trading, but can work perfectly fine for any same-asset.  That is one
catch in this version - it only works for one asset at a time (for now).  It also is easily ported into a Terminal cmd
with the addition of an alias to the program directory or by running Terminal within the program directory.  Then
simply type:

RUN FROM COMMAND LINE
$ cd /your/drive/capitalgains
$ CapGains4_2.py --method ["fifo", "lifo", "hifo"]
# defaults to fifo if no method is named

DEPENDENCIES (Need to install manually or run script to batch install):
import io, sys, csv, yaml, shutil, re
import tkinter as tk
from tkinter import messagebox
from pathlib import Path
from datetime import datetime
from decimal import Decimal

The calculation will return in the Terminal and the exported capital gains file will be in /exports.

This does not aim to work as a complete, complex tax-compliant software, but rather a personal calculator and form
generator for those who know what they are doing.  Proper input with the FIFO method will produce documents compatible
with standard methods, but I cannot guarantee compliance - that is up to the user.  As of 2024 in the USA, FIFO method
in this program will produce a list of sales with associated dates and proceeds/cost basis that is tax compliant.  The
user must keep their own records.  Lots of official links and information is provided under the "US TAX LAW" doc in the
READ directory.

As of now, the HIFO and LIFO methods only provide calculations, but do not provide the required specific ID
(date, qty, cost) for each sale as is required on the IRS form 8949 when using these methods.  If using Specific ID, 
on Form 8949 you mark Box 3 “Specific identification” (not “LIFO” or “HIFO”).

Something to note: HIFO calculates strictly by highest cost basis, NOT highest "price" - goes by purchase, not sale.

More updates to come.  Enjoy the use of this as a trading and tax estimation tool.  When it's in a better place, this 
repo will be moved to a new, dedicated account for open source money management tools.


1. DESIGN GOALS

Package dependencies installation guide or included in repo / script to install
Currently only tested for Mac, but should work wherever Python works
Compile design goals from script docstrings
Get working for multiple assets in one CSV
Get working for multiple CSVs in import folder
Work around specific-name import file (anything in folder will be imported)
Implement specific ID, for fully custom accounting and for HIFO/LIFO exports
Never overwrite /imports/transactions.csv
Original import gets copied to /working_files before the other processes run, then verified against before deleting.
Always work on copies in /working_files/…
Add CostBasis (Price * Qty) and make new file
Auto-detect date format and sort ascending (fast)
Optional quarantine of import file + SHA-256 verification
Bypass if an import has already succeeded on the same file
Prompt user when a duplicate basename exists
Prompt user if import file is missing
Build as DMG, DEB, EXE installation packages


2. DEFAULT FILE / FOLDER CONSTANTS (paths.yaml)

WORKING_DIR: "working_files"
IMPORT_CSV: "imports/transactions.csv"
EXPORT_DIR: "exports"
ARCHIVE_DIR: "working_files/archived"
MAIN_CSV: "working_files/transactions_formatted.csv"
EXPORT_CSV: "exports/capital_gains.csv"
# export CSV name gets tagged per method within script, this is just a fallback








******************************************************************
THE FOLLOWING IS FOR PERSONAL/DEVELOPER USE AND REFERENCE
******************************************************************

3. FAST DATE PARSING MACRO

from datetime import datetime
import re

DATE_RE = re.compile(r"(\d{4})[-/]?(\d{1,2})[-/]?(\d{1,2})")

def safe_date(date_str: str) -> datetime:
    """Return datetime from yyyy-mm-dd, yyyy/mm/dd, mm/dd/yyyy, etc."""
    m = DATE_RE.match(date_str.strip())
    if not m:
        raise ValueError(f"Unrecognized date: {date_str}")
    y, mon, d = map(int, m.groups())
    # Heuristic: if year < 100 treat as 20yy
    if y < 100:
        y += 2000
    return datetime(y, mon, d)



4. IMPORT-AND-PREPARE FUNCTION

import csv, shutil, hashlib, os
from typing import List, Dict, Tuple

_IMPORT_DONE: Dict[str, bool] = {}   # cache for bypass

def import_transactions() -> Tuple[bool, Path, Path]:
    """
    Return (success, hifo_path, fifo_lifo_path)
    """
    src = TRANSACTION_CSV.resolve()
    key = str(src)

    # 1.  Bypass if already succeeded on this exact file
    if _IMPORT_DONE.get(key, False):
        print("✅  Import already completed – skipping.")
        return True, HIFO_CSV, FIFO_LIFO_CSV

    # 2.  Duplicate-basename check / prompt
    basename = src.name
    if (WORKING_DIR / basename).exists():
        print(f"⚠️  File {basename} already exists in /working_files.")
        choice = input("Archive existing copy and proceed? [y/N]: ").strip().lower()
        if choice != "y":
            print("Aborted.")
            return False, Path(), Path()
        archive_old()

    # 3.  Load entire CSV into memory (quarantine)
    with src.open(newline="", encoding="utf-8") as f:
        rows = list(csv.DictReader(f))

    if not rows:
        print("Empty CSV – nothing to do.")
        return True, HIFO_CSV, FIFO_LIFO_CSV

    # 4.  Add CostBasis column if missing
    for row in rows:
        row.setdefault("CostBasis", float(row["PricePerUnit"]) * float(row["Qty"]))
        row.setdefault("Notes", "")

    # 5.  Fast sort by date (O(n log n))
    rows.sort(key=lambda r: safe_date(r["Date"]))

    # 6.  Write two copies
    fields = ["Date", "Action", "Qty", "PricePerUnit", "CostBasis", "Notes"]
    with HIFO_CSV.open("w", newline="", encoding="utf-8") as h:
        w = csv.DictWriter(h, fieldnames=fields)
        w.writeheader()
        w.writerows(rows)

    with FIFO_LIFO_CSV.open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        w.writerows(rows)

    # 7.  Quarantine check – compare SHA-256
    if verify_files(src, HIFO_CSV):
        _IMPORT_DONE[key] = True
        print("✅  Import finished and verified.")
        return True, HIFO_CSV, FIFO_LIFO_CSV
    else:
        print("❌  Verification failed.")
        return False, Path(), Path()

def archive_old():
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    today = datetime.today().strftime("%Y-%m-%d")
    for p in WORKING_DIR.glob("transactions*.csv"):
        if p.is_file():
            new_name = p.with_name(f"{p.stem}_{today}{p.suffix}")
            shutil.move(str(p), str(ARCHIVE_DIR / new_name))

def verify_files(src: Path, dst: Path) -> bool:
    """Return True if SHA256 of src == dst (quick binary check)."""
    def sha256(p):
        h = hashlib.sha256()
        with p.open("rb") as f:
            for chunk in iter(lambda: f.read(1 << 15), b""):
                h.update(chunk)
        return h.hexdigest()
    return sha256(src) == sha256(dst)



5. QUARANTINE BYPASS FLAG
The global _IMPORT_DONE dictionary lets downstream code know:

success, hifo, fifolifo = import_transactions()
if success:
    # proceed to FIFO/LIFO calculation
    ...



6. COINBASE FUTURE-PROOFING (stub)
If the Coinbase export has extra columns, just extend the fields list:

fields = ["Date", "Action", "Qty", "PricePerUnit", "CostBasis", "Notes"]  # add more



7. EMPTY IRS F-8949 TEMPLATE

def create_empty_f8949():
    f8949_fields = [
        "Description", "DateAcquired", "DateSold", "Proceeds", "CostBasis",
        "GainLoss", "Adjustment"
    ]
    with open(ROOT / "exports" / "IRS_f8949.csv", "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(f8949_fields)



8. ENTRY POINT

if __name__ == "__main__":
    ok, hifo_path, fifo_path = import_transactions()
    if ok:
        create_empty_f8949()
        print(f"Ready to consume:\n  HIFO: {hifo_path}\n  FIFO/LIFO: {fifo_path}")


9. MORE CODE SNIPPET REFERENCES

# ------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------
SUFFIX_FMT = "%Y-%m-%d_%H-%M-%S"
_ORIGINAL_BACKUP: Path = None    # keeps path of the untouched copy

# ------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------
_IMPORT_DONE: dict  = {}

# ------------------------------------------------------------------
# Utilities
# ------------------------------------------------------------------
DATE_RE = re.compile(r"(\d{4})[-/]?(\d{1,2})[-/]?(\d{1,2})")

def safe_date(date_str: str) -> datetime:
    m = DATE_RE.match(date_str.strip())
    if not m:
        raise ValueError(f"Unrecognized date: {date_str}")
    y, mon, d = map(int, m.groups())
    if y < 100:
        y += 2000
    return datetime(y, mon, d)
# This does pose a Y1K and Y3K risk, for what it's worth.  Data from the 1990s into 2000s will flip 1990s to 2090s.

def archive_old():
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    today = datetime.today().strftime("%Y-%m-%d")
    for p in WORKING_DIR.glob("transactions*.csv"):
        if p.is_file():
            new_name = p.with_name(f"{p.stem}_{today}{p.suffix}")
            shutil.move(str(p), str(ARCHIVE_DIR / new_name))

# # Version 1, original, no associated blocks
def verify_files(src: Path, dst: Path) -> bool:
    def sha256(p):
        h = hashlib.sha256()
        with p.open("rb") as f:
            for chunk in iter(lambda: f.read(1 << 15), b""):
                h.update(chunk)
        return h.hexdigest()
    return sha256(src) == sha256(dst)

# Version 3, verification without SHA256
def is_modified_since(src: Path, backup: Path) -> bool:
    return os.path.getmtime(src) != os.path.getmtime(backup)

    # prompt for duplicate basename
    basename = src.name
    if (WORKING_DIR / basename).exists():
        print(f"⚠️ File {basename} already exists in /working_files.")
        choice = input("Archive existing and proceed? [y/N]: ").strip().lower()
        if choice != "y":
            print("Aborted.")
            return False, None, None
        archive_old()

    # ---- 1. QUARANTINE COPY BEFORE ANY CHANGE ----
    stamp = datetime.now().strftime(SUFFIX_FMT)
    _ORIGINAL_BACKUP = WORKING_DIR / f"{src.stem}_{stamp}{src.suffix}"
    WORKING_DIR.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, _ORIGINAL_BACKUP)   # exact byte-for-byte copy


    # ---------- Load ----------
    with src.open(newline="", encoding="utf-8") as f:
        rows = list(csv.DictReader(f))
    if not rows:
        print("Empty CSV – nothing to do.")
        return True, HIFO_CSV, FIFO_LIFO_CSV  #why does this exist?

    # return True lets downstream code continue without a special-case branch;
    # callers just check the boolean and use the returned paths.
    # If you prefer, you can raise an exception instead.

    # ---------- Verify ----------
    if verify_files(src, _ORIGINAL_BACKUP):
        _IMPORT_DONE[key] = True   # Need to learn how this works
        print("✅ Import finished and verified.")
        return True, HIFO_CSV, FIFO_LIFO_CSV
    else:
        print("❌ Verification failed.")
        return False, None, None

    # Version 3, uses "last modified" check, instead of SHA256 hash
    # noinspection PyUnreachableCode
    if is_modified_since(src, _ORIGINAL_BACKUP):
        raise RuntimeError(
                    f"The source file has been altered *after* our copy was made.\n"
                    f"Nothing was overwritten.  Your untouched backup is:\n"
                    f"{_ORIGINAL_BACKUP}"
                )

    # ---- 5. Clean up quarantine copy ----
        # noinspection PyUnreachableCode
    _ORIGINAL_BACKUP.unlink(missing_ok=True)
    _IMPORT_DONE[key] = True
    return True, HIFO_CSV, FIFO_LIFO_CSV


    # # Works with Version 2 verification
    # block on line 63-68 (look for nearby verification block "def file_hash()")
    # noinspection PyUnreachableCode
    if file_hash(src) == file_hash(_ORIGINAL_BACKUP):
        _ORIGINAL_BACKUP.unlink(missing_ok=True)  # clean up
        _IMPORT_DONE[key] = True
        return True, HIFO_CSV, FIFO_LIFO_CSV
    else:
        raise RuntimeError(
            f"Source file was modified after backup.\n"
            f"Backup copy is safe at {_ORIGINAL_BACKUP}"
        )


# The “unreachable code” warning is coming from **PyCharm’s static analyzer / linter**, **not** Python itself.
# It believes the `if` condition is always `False` under normal circumstances, so the `raise …`
# and the lines after it **look** unreachable.
# You can simply ignore the warning or add `# noinspection PyUnreachableCode` above the `if`,
# if you prefer the warning to disappear.


# ------------------------------------------------------------------
# IRS F-8949 stub
# ------------------------------------------------------------------
def create_empty_f8949():
    IRS_F8949_CSV.parent.mkdir(parents=True, exist_ok=True)
    with IRS_F8949_CSV.open("w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([
            "Description", "DateAcquired", "DateSold", "Proceeds", "CostBasis",
            "GainLoss", "Adjustment"
        ])

# running it with "__main__" allows the whole program to be run via terminal: "python3 importer.py"
# running it with run() allows it to be called from another local program with "import file_prep; file_prep.run()"
